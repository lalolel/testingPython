{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Matplotlib Basics Guide\n",
        "\n",
        "A quick reference for essential matplotlib plotting techniques in Python."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 1. Basic Setup and Imports"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "\n",
        "# Enable inline plotting in Jupyter\n",
        "%matplotlib inline\n",
        "\n",
        "# Optional: Set default figure size\n",
        "plt.rcParams['figure.figsize'] = (10, 6)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 2. Simple Line Plot"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Sample data\n",
        "x = np.linspace(0, 10, 100)\n",
        "y = np.sin(x)\n",
        "\n",
        "# Create plot\n",
        "plt.figure(figsize=(8, 5))\n",
        "plt.plot(x, y)\n",
        "plt.title('Simple Sine Wave')\n",
        "plt.xlabel('X values')\n",
        "plt.ylabel('Y values')\n",
        "plt.grid(True)\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 3. Multiple Lines with Styling"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "x = np.linspace(0, 2*np.pi, 100)\n",
        "y1 = np.sin(x)\n",
        "y2 = np.cos(x)\n",
        "y3 = np.sin(2*x)\n",
        "\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.plot(x, y1, 'b-', label='sin(x)', linewidth=2)\n",
        "plt.plot(x, y2, 'r--', label='cos(x)', linewidth=2)\n",
        "plt.plot(x, y3, 'g:', label='sin(2x)', linewidth=2)\n",
        "\n",
        "plt.title('Trigonometric Functions')\n",
        "plt.xlabel('Angle (radians)')\n",
        "plt.ylabel('Value')\n",
        "plt.legend()\n",
        "plt.grid(True, alpha=0.3)\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 4. Scatter Plot"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Random data\n",
        "np.random.seed(42)\n",
        "x = np.random.randn(100)\n",
        "y = 2 * x + np.random.randn(100)\n",
        "colors = np.random.rand(100)\n",
        "\n",
        "plt.figure(figsize=(8, 6))\n",
        "plt.scatter(x, y, c=colors, alpha=0.7, s=50)\n",
        "plt.colorbar(label='Color Scale')\n",
        "plt.title('Scatter Plot with Color Mapping')\n",
        "plt.xlabel('X values')\n",
        "plt.ylabel('Y values')\n",
        "plt.grid(True, alpha=0.3)\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 5. Bar Chart"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Sample data\n",
        "categories = ['A', 'B', 'C', 'D', 'E']\n",
        "values = [23, 45, 56, 78, 32]\n",
        "\n",
        "plt.figure(figsize=(8, 5))\n",
        "bars = plt.bar(categories, values, color=['red', 'blue', 'green', 'orange', 'purple'])\n",
        "plt.title('Sample Bar Chart')\n",
        "plt.xlabel('Categories')\n",
        "plt.ylabel('Values')\n",
        "\n",
        "# Add value labels on bars\n",
        "for bar, value in zip(bars, values):\n",
        "    plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 1, \n",
        "             str(value), ha='center', va='bottom')\n",
        "\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 6. Histogram"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Generate random data\n",
        "np.random.seed(42)\n",
        "data = np.random.normal(100, 15, 1000)\n",
        "\n",
        "plt.figure(figsize=(8, 5))\n",
        "plt.hist(data, bins=30, alpha=0.7, color='skyblue', edgecolor='black')\n",
        "plt.title('Normal Distribution Histogram')\n",
        "plt.xlabel('Values')\n",
        "plt.ylabel('Frequency')\n",
        "plt.axvline(data.mean(), color='red', linestyle='--', \n",
        "           label=f'Mean: {data.mean():.1f}')\n",
        "plt.legend()\n",
        "plt.grid(True, alpha=0.3)\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 7. Subplots"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Create sample data\n",
        "x = np.linspace(0, 10, 100)\n",
        "y1 = np.sin(x)\n",
        "y2 = np.cos(x)\n",
        "y3 = np.exp(-x/5)\n",
        "y4 = x**2\n",
        "\n",
        "# Create 2x2 subplot grid\n",
        "fig, axes = plt.subplots(2, 2, figsize=(12, 8))\n",
        "fig.suptitle('Multiple Subplots Example')\n",
        "\n",
        "# Plot 1: Sine wave\n",
        "axes[0, 0].plot(x, y1, 'b-')\n",
        "axes[0, 0].set_title('Sine Wave')\n",
        "axes[0, 0].grid(True)\n",
        "\n",
        "# Plot 2: Cosine wave\n",
        "axes[0, 1].plot(x, y2, 'r-')\n",
        "axes[0, 1].set_title('Cosine Wave')\n",
        "axes[0, 1].grid(True)\n",
        "\n",
        "# Plot 3: Exponential decay\n",
        "axes[1, 0].plot(x, y3, 'g-')\n",
        "axes[1, 0].set_title('Exponential Decay')\n",
        "axes[1, 0].grid(True)\n",
        "\n",
        "# Plot 4: Quadratic\n",
        "axes[1, 1].plot(x, y4, 'm-')\n",
        "axes[1, 1].set_title('Quadratic Function')\n",
        "axes[1, 1].grid(True)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 8. Customization Examples"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Advanced customization\n",
        "x = np.linspace(0, 4*np.pi, 200)\n",
        "y = np.sin(x) * np.exp(-x/8)\n",
        "\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.plot(x, y, linewidth=3, color='darkblue')\n",
        "plt.fill_between(x, y, alpha=0.3, color='lightblue')\n",
        "\n",
        "# Customize appearance\n",
        "plt.title('Damped Sine Wave', fontsize=16, fontweight='bold')\n",
        "plt.xlabel('Time', fontsize=12)\n",
        "plt.ylabel('Amplitude', fontsize=12)\n",
        "\n",
        "# Set axis limits\n",
        "plt.xlim(0, 4*np.pi)\n",
        "\n",
        "# Add annotations\n",
        "plt.annotate('Peak amplitude', xy=(0, 1), xytext=(2, 0.5),\n",
        "            arrowprops=dict(arrowstyle='->', color='red'),\n",
        "            fontsize=10)\n",
        "\n",
        "plt.grid(True, alpha=0.3)\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 9. Common Plot Styles and Colors"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Line styles and markers reference\n",
        "x = np.linspace(0, 10, 20)\n",
        "\n",
        "plt.figure(figsize=(12, 8))\n",
        "\n",
        "# Different line styles\n",
        "plt.plot(x, x, 'b-', label='solid line')\n",
        "plt.plot(x, x+1, 'r--', label='dashed line')\n",
        "plt.plot(x, x+2, 'g-.', label='dash-dot line')\n",
        "plt.plot(x, x+3, 'm:', label='dotted line')\n",
        "\n",
        "# Different markers\n",
        "plt.plot(x[::2], (x+4)[::2], 'ko', label='circle markers')\n",
        "plt.plot(x[::2], (x+5)[::2], 'rs', label='square markers')\n",
        "plt.plot(x[::2], (x+6)[::2], '^b', label='triangle markers')\n",
        "\n",
        "plt.title('Line Styles and Markers')\n",
        "plt.xlabel('X values')\n",
        "plt.ylabel('Y values')\n",
        "plt.legend()\n",
        "plt.grid(True, alpha=0.3)\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 10. Saving Plots"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Create a sample plot\n",
        "x = np.linspace(0, 2*np.pi, 100)\n",
        "y = np.sin(x)\n",
        "\n",
        "plt.figure(figsize=(8, 5))\n",
        "plt.plot(x, y, 'b-', linewidth=2)\n",
        "plt.title('Plot to Save')\n",
        "plt.xlabel('X')\n",
        "plt.ylabel('Y')\n",
        "plt.grid(True)\n",
        "\n",
        "# Save in different formats\n",
        "# plt.savefig('my_plot.png', dpi=300, bbox_inches='tight')\n",
        "# plt.savefig('my_plot.pdf', bbox_inches='tight')\n",
        "# plt.savefig('my_plot.svg', bbox_inches='tight')\n",
        "\n",
        "plt.show()\n",
        "\n",
        "print(\"Uncomment the savefig lines above to save plots to files\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Finance-Specific Plotting Examples\n",
        "\n",
        "Advanced matplotlib examples tailored for financial data visualization."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 11. Time Series - Stock Price Chart"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "import pandas as pd\n",
        "from datetime import datetime, timedelta\n",
        "\n",
        "# Generate sample stock data\n",
        "np.random.seed(42)\n",
        "dates = pd.date_range(start='2023-01-01', end='2024-01-01', freq='D')\n",
        "returns = np.random.normal(0.001, 0.02, len(dates))\n",
        "price = 100 * np.exp(np.cumsum(returns))\n",
        "\n",
        "plt.figure(figsize=(12, 6))\n",
        "plt.plot(dates, price, 'b-', linewidth=1.5, label='Stock Price')\n",
        "\n",
        "# Add moving averages\n",
        "ma_20 = pd.Series(price).rolling(20).mean()\n",
        "ma_50 = pd.Series(price).rolling(50).mean()\n",
        "\n",
        "plt.plot(dates, ma_20, 'orange', linewidth=2, label='20-day MA')\n",
        "plt.plot(dates, ma_50, 'red', linewidth=2, label='50-day MA')\n",
        "\n",
        "plt.title('Stock Price with Moving Averages', fontsize=14)\n",
        "plt.xlabel('Date')\n",
        "plt.ylabel('Price ($)')\n",
        "plt.legend()\n",
        "plt.grid(True, alpha=0.3)\n",
        "plt.xticks(rotation=45)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 12. Candlestick Chart (OHLC)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Generate OHLC data\n",
        "np.random.seed(42)\n",
        "n_days = 30\n",
        "dates = pd.date_range(start='2024-01-01', periods=n_days, freq='D')\n",
        "\n",
        "# Simulate OHLC data\n",
        "open_prices = []\n",
        "high_prices = []\n",
        "low_prices = []\n",
        "close_prices = []\n",
        "\n",
        "price = 100\n",
        "for i in range(n_days):\n",
        "    open_p = price\n",
        "    change = np.random.normal(0, 2)\n",
        "    close_p = open_p + change\n",
        "    high_p = max(open_p, close_p) + abs(np.random.normal(0, 1))\n",
        "    low_p = min(open_p, close_p) - abs(np.random.normal(0, 1))\n",
        "    \n",
        "    open_prices.append(open_p)\n",
        "    high_prices.append(high_p)\n",
        "    low_prices.append(low_p)\n",
        "    close_prices.append(close_p)\n",
        "    price = close_p\n",
        "\n",
        "# Create candlestick-style chart\n",
        "fig, ax = plt.subplots(figsize=(14, 8))\n",
        "\n",
        "for i in range(len(dates)):\n",
        "    date = i\n",
        "    open_p, high_p, low_p, close_p = open_prices[i], high_prices[i], low_prices[i], close_prices[i]\n",
        "    \n",
        "    # Color based on price movement\n",
        "    color = 'green' if close_p >= open_p else 'red'\n",
        "    \n",
        "    # Draw high-low line\n",
        "    ax.plot([date, date], [low_p, high_p], color='black', linewidth=1)\n",
        "    \n",
        "    # Draw open-close rectangle\n",
        "    height = abs(close_p - open_p)\n",
        "    bottom = min(open_p, close_p)\n",
        "    ax.bar(date, height, bottom=bottom, width=0.6, color=color, alpha=0.8)\n",
        "\n",
        "ax.set_title('Candlestick Chart (OHLC)', fontsize=14)\n",
        "ax.set_xlabel('Trading Days')\n",
        "ax.set_ylabel('Price ($)')\n",
        "ax.grid(True, alpha=0.3)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 13. Portfolio Performance & Drawdown"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Generate portfolio data\n",
        "np.random.seed(42)\n",
        "dates = pd.date_range(start='2023-01-01', periods=252, freq='D')  # 1 year of trading days\n",
        "returns = np.random.normal(0.0008, 0.015, len(dates))  # Daily returns\n",
        "portfolio_value = 100000 * np.exp(np.cumsum(returns))  # Portfolio value\n",
        "\n",
        "# Calculate drawdown\n",
        "rolling_max = pd.Series(portfolio_value).expanding().max()\n",
        "drawdown = (portfolio_value - rolling_max) / rolling_max * 100\n",
        "\n",
        "# Create subplot\n",
        "fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10), sharex=True)\n",
        "\n",
        "# Portfolio value plot\n",
        "ax1.plot(dates, portfolio_value, 'b-', linewidth=2, label='Portfolio Value')\n",
        "ax1.plot(dates, rolling_max, 'g--', alpha=0.7, label='All-time High')\n",
        "ax1.set_title('Portfolio Performance', fontsize=14)\n",
        "ax1.set_ylabel('Portfolio Value ($)')\n",
        "ax1.legend()\n",
        "ax1.grid(True, alpha=0.3)\n",
        "ax1.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))\n",
        "\n",
        "# Drawdown plot\n",
        "ax2.fill_between(dates, drawdown, 0, color='red', alpha=0.3, label='Drawdown')\n",
        "ax2.plot(dates, drawdown, 'r-', linewidth=1)\n",
        "ax2.set_title('Portfolio Drawdown', fontsize=14)\n",
        "ax2.set_xlabel('Date')\n",
        "ax2.set_ylabel('Drawdown (%)')\n",
        "ax2.legend()\n",
        "ax2.grid(True, alpha=0.3)\n",
        "\n",
        "plt.xticks(rotation=45)\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "print(f\"Max Drawdown: {drawdown.min():.2f}%\")\n",
        "print(f\"Final Portfolio Value: ${portfolio_value[-1]:,.0f}\")\n",
        "print(f\"Total Return: {(portfolio_value[-1]/portfolio_value[0] - 1)*100:.2f}%\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 14. Risk-Return Scatter Plot"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Generate sample asset data\n",
        "np.random.seed(42)\n",
        "n_assets = 20\n",
        "\n",
        "# Risk (volatility) and return data\n",
        "annual_returns = np.random.normal(0.08, 0.05, n_assets)\n",
        "annual_volatility = np.random.uniform(0.05, 0.25, n_assets)\n",
        "market_caps = np.random.uniform(1, 100, n_assets)  # For bubble size\n",
        "\n",
        "# Asset names\n",
        "asset_names = [f'Asset_{i+1}' for i in range(n_assets)]\n",
        "\n",
        "plt.figure(figsize=(12, 8))\n",
        "\n",
        "# Create scatter plot with bubble sizes\n",
        "scatter = plt.scatter(annual_volatility * 100, annual_returns * 100, \n",
        "                     s=market_caps * 10, alpha=0.6, c=annual_returns,\n",
        "                     cmap='RdYlGn', edgecolors='black', linewidth=0.5)\n",
        "\n",
        "# Add colorbar\n",
        "cbar = plt.colorbar(scatter)\n",
        "cbar.set_label('Annual Return', rotation=270, labelpad=20)\n",
        "\n",
        "# Add labels for some points\n",
        "for i in range(0, n_assets, 5):  # Label every 5th asset\n",
        "    plt.annotate(asset_names[i], \n",
        "                (annual_volatility[i] * 100, annual_returns[i] * 100),\n",
        "                xytext=(5, 5), textcoords='offset points', fontsize=8)\n",
        "\n",
        "plt.title('Risk-Return Analysis (Bubble size = Market Cap)', fontsize=14)\n",
        "plt.xlabel('Annual Volatility (%)')\n",
        "plt.ylabel('Annual Return (%)')\n",
        "plt.grid(True, alpha=0.3)\n",
        "\n",
        "# Add reference lines\n",
        "plt.axhline(y=0, color='black', linestyle='-', alpha=0.3)\n",
        "plt.axvline(x=15, color='red', linestyle='--', alpha=0.5, label='15% Vol Threshold')\n",
        "\n",
        "plt.legend()\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 15. Financial Returns Distribution"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Generate daily returns data\n",
        "np.random.seed(42)\n",
        "returns_normal = np.random.normal(0.001, 0.02, 1000)\n",
        "returns_actual = np.concatenate([\n",
        "    np.random.normal(0.001, 0.015, 900),  # Normal market conditions\n",
        "    np.random.normal(-0.05, 0.03, 100)    # Market stress (fat tails)\n",
        "])\n",
        "\n",
        "fig, axes = plt.subplots(2, 2, figsize=(14, 10))\n",
        "\n",
        "# Histogram comparison\n",
        "axes[0, 0].hist(returns_normal * 100, bins=50, alpha=0.7, label='Normal Distribution', density=True)\n",
        "axes[0, 0].hist(returns_actual * 100, bins=50, alpha=0.7, label='Actual Returns', density=True)\n",
        "axes[0, 0].set_title('Returns Distribution Comparison')\n",
        "axes[0, 0].set_xlabel('Daily Returns (%)')\n",
        "axes[0, 0].set_ylabel('Density')\n",
        "axes[0, 0].legend()\n",
        "axes[0, 0].grid(True, alpha=0.3)\n",
        "\n",
        "# Q-Q plot approximation\n",
        "sorted_normal = np.sort(returns_normal)\n",
        "sorted_actual = np.sort(returns_actual)\n",
        "axes[0, 1].scatter(sorted_normal * 100, sorted_actual * 100, alpha=0.5, s=10)\n",
        "axes[0, 1].plot([-8, 6], [-8, 6], 'r--', label='Perfect Normal')\n",
        "axes[0, 1].set_title('Q-Q Plot: Actual vs Normal')\n",
        "axes[0, 1].set_xlabel('Theoretical Normal (%)')\n",
        "axes[0, 1].set_ylabel('Actual Returns (%)')\n",
        "axes[0, 1].legend()\n",
        "axes[0, 1].grid(True, alpha=0.3)\n",
        "\n",
        "# Rolling volatility\n",
        "rolling_vol = pd.Series(returns_actual).rolling(30).std() * np.sqrt(252) * 100\n",
        "axes[1, 0].plot(rolling_vol, 'purple', linewidth=1.5)\n",
        "axes[1, 0].set_title('30-Day Rolling Volatility')\n",
        "axes[1, 0].set_xlabel('Days')\n",
        "axes[1, 0].set_ylabel('Annualized Volatility (%)')\n",
        "axes[1, 0].grid(True, alpha=0.3)\n",
        "\n",
        "# Cumulative returns\n",
        "cum_returns = (1 + pd.Series(returns_actual)).cumprod()\n",
        "axes[1, 1].plot(cum_returns, 'green', linewidth=2)\n",
        "axes[1, 1].set_title('Cumulative Returns')\n",
        "axes[1, 1].set_xlabel('Days')\n",
        "axes[1, 1].set_ylabel('Cumulative Return Factor')\n",
        "axes[1, 1].grid(True, alpha=0.3)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "# Print statistics\n",
        "print(f\"Actual Returns - Mean: {np.mean(returns_actual)*100:.3f}%, Std: {np.std(returns_actual)*100:.3f}%\")\n",
        "print(f\"Skewness: {pd.Series(returns_actual).skew():.3f}\")\n",
        "print(f\"Kurtosis: {pd.Series(returns_actual).kurtosis():.3f}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 16. Correlation Heatmap"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Generate correlated asset returns\n",
        "np.random.seed(42)\n",
        "n_assets = 8\n",
        "n_days = 252\n",
        "\n",
        "# Create correlation matrix\n",
        "base_corr = np.random.uniform(0.1, 0.7, (n_assets, n_assets))\n",
        "correlation_matrix = (base_corr + base_corr.T) / 2\n",
        "np.fill_diagonal(correlation_matrix, 1.0)\n",
        "\n",
        "# Generate correlated returns using Cholesky decomposition\n",
        "L = np.linalg.cholesky(correlation_matrix)\n",
        "uncorrelated = np.random.normal(0, 0.02, (n_days, n_assets))\n",
        "correlated_returns = uncorrelated @ L.T\n",
        "\n",
        "# Asset names\n",
        "asset_names = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'NVDA', 'META', 'NFLX']\n",
        "\n",
        "# Calculate actual correlation from generated data\n",
        "actual_corr = np.corrcoef(correlated_returns.T)\n",
        "\n",
        "# Create heatmap\n",
        "fig, ax = plt.subplots(figsize=(10, 8))\n",
        "im = ax.imshow(actual_corr, cmap='RdBu', vmin=-1, vmax=1)\n",
        "\n",
        "# Add colorbar\n",
        "cbar = plt.colorbar(im, ax=ax)\n",
        "cbar.set_label('Correlation Coefficient', rotation=270, labelpad=20)\n",
        "\n",
        "# Set ticks and labels\n",
        "ax.set_xticks(np.arange(n_assets))\n",
        "ax.set_yticks(np.arange(n_assets))\n",
        "ax.set_xticklabels(asset_names)\n",
        "ax.set_yticklabels(asset_names)\n",
        "\n",
        "# Rotate the tick labels and set their alignment\n",
        "plt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\", rotation_mode=\"anchor\")\n",
        "\n",
        "# Add correlation values as text\n",
        "for i in range(n_assets):\n",
        "    for j in range(n_assets):\n",
        "        text = ax.text(j, i, f'{actual_corr[i, j]:.2f}',\n",
        "                      ha=\"center\", va=\"center\", color=\"white\" if abs(actual_corr[i, j]) > 0.5 else \"black\")\n",
        "\n",
        "ax.set_title('Asset Correlation Heatmap', fontsize=14, pad=20)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 17. Option Payoff Diagrams"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Option parameters\n",
        "S0 = 100  # Current stock price\n",
        "K = 100   # Strike price\n",
        "premium_call = 5\n",
        "premium_put = 4\n",
        "\n",
        "# Stock price range\n",
        "S = np.linspace(70, 130, 100)\n",
        "\n",
        "# Payoff calculations\n",
        "call_payoff = np.maximum(S - K, 0) - premium_call\n",
        "put_payoff = np.maximum(K - S, 0) - premium_put\n",
        "stock_payoff = S - S0\n",
        "straddle_payoff = call_payoff + put_payoff + premium_call + premium_put  # Long straddle\n",
        "\n",
        "# Create subplot for different strategies\n",
        "fig, axes = plt.subplots(2, 2, figsize=(14, 10))\n",
        "\n",
        "# Long Call\n",
        "axes[0, 0].plot(S, call_payoff, 'g-', linewidth=2, label='Long Call')\n",
        "axes[0, 0].axhline(y=0, color='black', linestyle='-', alpha=0.3)\n",
        "axes[0, 0].axvline(x=K, color='red', linestyle='--', alpha=0.5, label=f'Strike ${K}')\n",
        "axes[0, 0].fill_between(S, call_payoff, 0, where=(call_payoff > 0), alpha=0.3, color='green')\n",
        "axes[0, 0].fill_between(S, call_payoff, 0, where=(call_payoff < 0), alpha=0.3, color='red')\n",
        "axes[0, 0].set_title('Long Call Option')\n",
        "axes[0, 0].set_ylabel('Profit/Loss ($)')\n",
        "axes[0, 0].legend()\n",
        "axes[0, 0].grid(True, alpha=0.3)\n",
        "\n",
        "# Long Put\n",
        "axes[0, 1].plot(S, put_payoff, 'r-', linewidth=2, label='Long Put')\n",
        "axes[0, 1].axhline(y=0, color='black', linestyle='-', alpha=0.3)\n",
        "axes[0, 1].axvline(x=K, color='red', linestyle='--', alpha=0.5, label=f'Strike ${K}')\n",
        "axes[0, 1].fill_between(S, put_payoff, 0, where=(put_payoff > 0), alpha=0.3, color='green')\n",
        "axes[0, 1].fill_between(S, put_payoff, 0, where=(put_payoff < 0), alpha=0.3, color='red')\n",
        "axes[0, 1].set_title('Long Put Option')\n",
        "axes[0, 1].set_ylabel('Profit/Loss ($)')\n",
        "axes[0, 1].legend()\n",
        "axes[0, 1].grid(True, alpha=0.3)\n",
        "\n",
        "# Stock Position\n",
        "axes[1, 0].plot(S, stock_payoff, 'b-', linewidth=2, label='Long Stock')\n",
        "axes[1, 0].axhline(y=0, color='black', linestyle='-', alpha=0.3)\n",
        "axes[1, 0].axvline(x=S0, color='blue', linestyle='--', alpha=0.5, label=f'Entry ${S0}')\n",
        "axes[1, 0].fill_between(S, stock_payoff, 0, where=(stock_payoff > 0), alpha=0.3, color='green')\n",
        "axes[1, 0].fill_between(S, stock_payoff, 0, where=(stock_payoff < 0), alpha=0.3, color='red')\n",
        "axes[1, 0].set_title('Long Stock Position')\n",
        "axes[1, 0].set_xlabel('Stock Price ($)')\n",
        "axes[1, 0].set_ylabel('Profit/Loss ($)')\n",
        "axes[1, 0].legend()\n",
        "axes[1, 0].grid(True, alpha=0.3)\n",
        "\n",
        "# Long Straddle\n",
        "axes[1, 1].plot(S, straddle_payoff, 'm-', linewidth=2, label='Long Straddle')\n",
        "axes[1, 1].axhline(y=0, color='black', linestyle='-', alpha=0.3)\n",
        "axes[1, 1].axvline(x=K, color='red', linestyle='--', alpha=0.5, label=f'Strike ${K}')\n",
        "axes[1, 1].fill_between(S, straddle_payoff, 0, where=(straddle_payoff > 0), alpha=0.3, color='green')\n",
        "axes[1, 1].fill_between(S, straddle_payoff, 0, where=(straddle_payoff < 0), alpha=0.3, color='red')\n",
        "axes[1, 1].set_title('Long Straddle Strategy')\n",
        "axes[1, 1].set_xlabel('Stock Price ($)')\n",
        "axes[1, 1].set_ylabel('Profit/Loss ($)')\n",
        "axes[1, 1].legend()\n",
        "axes[1, 1].grid(True, alpha=0.3)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "# Print breakeven points\n",
        "call_breakeven = K + premium_call\n",
        "put_breakeven = K - premium_put\n",
        "straddle_breakeven_up = K + premium_call + premium_put\n",
        "straddle_breakeven_down = K - premium_call - premium_put\n",
        "\n",
        "print(f\"Call Breakeven: ${call_breakeven:.2f}\")\n",
        "print(f\"Put Breakeven: ${put_breakeven:.2f}\")\n",
        "print(f\"Straddle Breakevens: ${straddle_breakeven_down:.2f} and ${straddle_breakeven_up:.2f}\")"
      ]
    },
   {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Generate portfolio returns\n",
        "np.random.seed(42)\n",
        "portfolio_returns = np.random.normal(0.001, 0.02, 1000)\n",
        "portfolio_value = 1000000  # $1M portfolio\n",
        "\n",
        "# Calculate VaR at different confidence levels\n",
        "confidence_levels = [0.90, 0.95, 0.99]\n",
        "var_values = []\n",
        "\n",
        "for conf in confidence_levels:\n",
        "    var_percentile = np.percentile(portfolio_returns, (1 - conf) * 100)\n",
        "    var_dollar = var_percentile * portfolio_value\n",
        "    var_values.append((conf, var_percentile, var_dollar))\n",
        "\n",
        "# Create visualization\n",
        "fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))\n",
        "\n",
        "# Returns distribution with VaR levels\n",
        "ax1.hist(portfolio_returns * 100, bins=50, alpha=0.7, density=True, color='lightblue', edgecolor='black')\n",
        "\n",
        "colors = ['orange', 'red', 'darkred']\n",
        "for i, (conf, var_pct, var_dollar) in enumerate(var_values):\n",
        "    ax1.axvline(var_pct * 100, color=colors[i], linestyle='--', linewidth=2,\n",
        "               label=f'VaR {conf*100:.0f}%: {var_pct*100:.2f}%')\n",
        "\n",
        "ax1.set_title('Portfolio Returns Distribution with VaR Levels')\n",
        "ax1.set_xlabel('Daily Returns (%)')\n",
        "ax1.set_ylabel('Density')\n",
        "ax1.legend()\n",
        "ax1.grid(True, alpha=0.3)\n",
        "\n",
        "# VaR comparison chart\n",
        "conf_labels = [f'{conf*100:.0f}%' for conf, _, _ in var_values]\n",
        "var_amounts = [abs(var_dollar) for _, _, var_dollar in var_values]\n",
        "\n",
        "bars = ax2.bar(conf_labels, var_amounts, color=colors, alpha=0.7)\n",
        "ax2.set_title('Value at Risk by Confidence Level')\n",
        "ax2.set_xlabel('Confidence Level')\n",
        "ax2.set_ylabel('VaR Amount ($)')\n",
        "\n",
        "# Add value labels on bars\n",
        "for bar, amount in zip(bars, var_amounts):\n",
        "    ax2.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 1000,\n",
        "             f'${amount:,.0f}', ha='center', va='bottom')\n",
        "\n",
        "ax2.grid(True, alpha=0.3)\n",
        "ax2.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "# Print VaR summary\n",
        "print(\"Value at Risk Summary:\")\n",
        "print(f\"Portfolio Value: ${portfolio_value:,}\")\n",
        "for conf, var_pct, var_dollar in var_values:\n",
        "    print(f\"{conf*100:.0f}% VaR: ${abs(var_dollar):,.0f} ({var_pct*100:.2f}%)\")"
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.8.0"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 4
}